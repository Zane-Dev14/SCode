def detect_vulnerabilities(node):
    """Detect potential vulnerabilities in function calls across languages."""
    vulnerabilities = []

    # Comprehensive list of vulnerable function patterns across languages
    vulnerable_patterns = {
        # Python
        'python': {
            'functions': [
                'eval', 'exec', 'os.system', 'os.popen', 'subprocess.run', 'subprocess.call', 
                'subprocess.Popen', 'subprocess.check_output', 'platform.popen', 
                'pickle.loads', 'cPickle.loads', 'yaml.load', 'input'  # Older Python 2.x raw_input
            ],
            'description': 'Potential command injection, code injection, or deserialization vulnerability'
        },
        # JavaScript
        'javascript': {
            'functions': [
                'eval', 'Function', 'setTimeout', 'setInterval', 'document.write', 
                'document.writeln', 'innerHTML', 'outerHTML', 'document.execCommand', 
                'window.execScript', 'new Function'
            ],
            'description': 'Potential code injection or XSS vulnerability'
        },
        # Java
        'java': {
            'functions': [
                'Runtime.exec', 'ProcessBuilder.start', 'ProcessBuilder.command', 
                'System.load', 'System.loadLibrary', 'Class.forName', 
                'java.sql.Statement.execute', 'java.sql.Statement.executeQuery', 
                'java.sql.Statement.executeUpdate'
            ],
            'description': 'Potential command injection, untrusted library loading, or SQL injection'
        },
        # C
        'c': {
            'functions': [
                'system', 'exec', 'execl', 'execlp', 'execle', 'execv', 'execvp', 'popen', 
                'gets', 'strcpy', 'strcat', 'sprintf', 'vsprintf', 'scanf', 'sscanf', 
                'strncpy', 'strncat'  # If misused without proper bounds
            ],
            'description': 'Potential command injection or buffer overflow vulnerability'
        },
        # C++
        'cpp': {
            'functions': [
                'system', 'exec', 'execl', 'execlp', 'execle', 'execv', 'execvp', 'popen', 
                'gets', 'strcpy', 'strcat', 'sprintf', 'vsprintf', 'scanf', 'sscanf', 
                'std::system', 'std::gets', 'std::strcpy', 'std::strcat'
            ],
            'description': 'Potential command injection or buffer overflow vulnerability'
        },
        # Go
        'go': {
            'functions': [
                'exec.Command', 'exec.CommandContext', 'syscall.Exec', 'os.StartProcess', 
                'os/exec.Command', 'database/sql.Query', 'database/sql.Exec'
            ],
            'description': 'Potential command injection or SQL injection vulnerability'
        },
        # Ruby
        'ruby': {
            'functions': [
                'eval', 'system', 'exec', '`', 'Kernel.eval', 'Kernel.system', 'Kernel.exec', 
                'send', 'public_send', 'const_get', 'constantize', 'ObjectSpace.load'
            ],
            'description': 'Potential command injection or code injection vulnerability'
        },
        # C#
        'c-sharp': {
            'functions': [
                'Process.Start', 'ProcessStartInfo', 'Activator.CreateInstance', 
                'Assembly.Load', 'Assembly.LoadFrom', 'Assembly.LoadFile', 
                'SqlCommand.ExecuteReader', 'SqlCommand.ExecuteNonQuery', 
                'SqlCommand.ExecuteScalar'
            ],
            'description': 'Potential command injection, untrusted library loading, or SQL injection'
        },
        # Rust
        'rust': {
            'functions': [
                'std::process::Command', 'std::process::Command::new', 
                'std::ptr::write', 'std::ptr::write_volatile', 'std::ptr::copy', 
                'std::mem::transmute', 'std::ffi::CString::new', 'std::fs::canonicalize'
            ],
            'description': 'Potential command injection or unsafe memory operation vulnerability'
        }
    }

    # Additional patterns for specific constructs (not just function calls)
    additional_checks = {
        # JavaScript XSS via property assignment
        'javascript_xss': {
            'pattern': lambda n: n.type == 'assignment_expression' and any(
                child.text.decode('utf-8') in ['innerHTML', 'outerHTML'] 
                for child in n.children if child.type == 'property_identifier'
            ),
            'description': 'Potential XSS via direct DOM manipulation'
        },
        # C/C++ buffer overflow via array access
        'c_cpp_buffer': {
            'pattern': lambda n: n.type == 'subscript_expression' and any(
                child.type == 'identifier' and child.text.decode('utf-8') in ['strcpy', 'strcat']
                for child in n.children
            ),
            'description': 'Potential buffer overflow in array access'
        },
        # Rust unsafe blocks
        'rust_unsafe': {
            'pattern': lambda n: n.type == 'unsafe_block',
            'description': 'Use of unsafe block may lead to memory safety issues'
        }
    }

    # Universal function call detection across languages
    call_types = ['call', 'call_expression', 'method_invocation', 'method_call']
    if node.type in call_types:
        function_name = None
        # Handle different ways functions are identified across languages
        for child in node.children:
            if child.type in ['identifier', 'dotted_name', 'member_expression', 'field_access', 'field_expression', 'scoped_identifier']:
                function_name = child.text.decode('utf-8')
                break
        
        # Check all language vulnerabilities
        if function_name:
            for lang, vuln_data in vulnerable_patterns.items():
                if any(vuln in function_name for vuln in vuln_data['functions']):
                    vulnerabilities.append(f"{vuln_data['description']}: {function_name}")
                    break  # Stop after first match to avoid duplicate reports

    # Additional vulnerability checks beyond function calls
    for check_name, check_data in additional_checks.items():
        if check_data['pattern'](node):
            vulnerabilities.append(f"{check_data['description']}")

    return vulnerabilities